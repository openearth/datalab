[uwsgi]
# Variables
root = /srv/{{ app_module }}
base = /srv/{{ app_module }}
log_path = /srv/{{ app_module }}/log
socket_path = /var/run/uwsgi
# %n vabriable for the filename without extension as default(repace it with the hostname for example)
name = %n

# Pass exceptions to nginx, do not use on production!
#catch-exceptions = true

# if emperor is run as root define the uid and pid here
uid = {{ app_user }}
gid = {{ app_group }}

# chown socket
chmod-socket = 666

#define plugins
plugins = python

# specicy workers, please change this according to the server capacity
workers = 5
max-requests = 300

#Threads will simply not work if this option is not enabled.
#There will likely be no error, just no execution of your thread code.
enable-threads = true

# buffer-size default is 4k
buffer-size 32768

# load applications after each worker's fork()
lazy = true

# set socket listen queue to <n> (default 100, maximum is system dependent)
listen = 100
socket = %(socket_path)/%(name).sock
# socket = %(socket_path)/%(name)2.sock

#gevent = 100
#gevent-monkey-patch = true
#http-websockets = true

# you can map specific workers to specific sockets
#map-socket = 0:1,2,3,4,5
#map-socket = 1:6,7,8,9,10

# set close-on-exec flag on the uWSGI socket. This will avoid external processes
# generated in a request to inherit the socket file descriptor..
close-on-exec = true

# change to django project directory
# at the root of uwsgi
chdir = %(base)/src/
home =  %(base)/src/
pythonpath = %(base)/

# when using a virtualenv
virtualenv = %(root)/venv/

# set the project settings name
env = DJANGO_SETTINGS_MODULE=openearth.settings.{{app_settings}}
include = /srv/{{ app_module }}/etc/env.ini

# load django
module = openearth.wsgi:application



# uwsgi log
# by default disable request logging. only internal messages and errors are logged.
# when enabled you should have a good logrotate because the log gets biig.
disable-logging = true
logto = %(log_path)/uwsgi.%(name).log
logdate = true
logslow = 2000 # log request slower than 2 seconds
logbig = 1000000 # log requests bigger than 1MB
log-5xx = true
logfile-chown = true

{% if app in ('openearth', 'zandmotor') %}
#attach Celery deamon
if-not-exists = %(socket_path)/celery.pid
exec-as-root = touch %(socket_path)/celery.pid && chown %(uid):%(gid) %(socket_path)/celery.pid && chmod 0770 %(socket_path)/celery.pid
smart-attach-daemon = %(socket_path)/celery.pid %(virtualenv)bin/celery worker --events --app=openearth --pidfile=%(socket_path)/celery.pid --logfile=%(log_path)/celery.log --loglevel=INFO
endif =
{% endif %}

# When using emperor do not use deamonize
#daemonize = %(log_path)/%(name).uwsgi.log

# use master process
master = true

# will set the uWSGI processes name to something meaningful automatically..
auto-procname = true
# prefix the name of the uWSGI processes with this filename
procname-prefix-spaced = %(name)

# use harakiri to kill requests cosing more than 30 seconds
harakiri = 30
# you will be told why killed in detail.
harakiri-verbose = true
# slow upload could be rejected on post-unbuffered webservers when harakiri is enabled
post-buffering = 4096

# memory leak , recycle worker if over 256M of address space growed.(not physicial memory)
# limit-as = 256M
# recycle a workers when its address space usage is over the limit specified
# reload-on-as = 128M.

# Some of the supported languages (like python) has the concept of "multiple interpreters". They allows to isolate
#single-interpreter = true

# set pidfile.
pidfile = %(socket_path)/%(name).pid
touch-reload = %p
{% if uwsgi_autoreload is defined and uwsgi_autoreload %}
py-autoreload = {{ uwsgi_autoreload }}
{% endif %}
